from preprocess_midi import get_all_midi_files2
from decode_to_midi import export_midi
import numpy as np


def midi_to_int_melody():
    # Assumes melody is in 0th channel, there is always only one note playing at the same time (so note on/off are
    # alternated) meters are the same and ticks_per_beat is 1024. The meter and tick_per_beat are always true for our
    # dataset, the rest is not sure.
    melodies = dict()
    # Should make sure that only files with proper amount of channels etc.
    midi_files = get_all_midi_files2()
    for s in range(0, len(midi_files)):
        melody = []
        for n in range(0, len(midi_files[s].channels[0]), 2):
            on = midi_files[s].channels[0][n]
            off = midi_files[s].channels[0][n+1]
            # Number of 1/16th notes the note is worth; 256 ticks = 1/16 note
            nr_notes = (off.time-on.time)//256

            melody.append(on.note)
            for i in range(0, nr_notes-1):
                melody.append(-2)  # -2 represents holding the note (or rest)
        melodies[s] = melody
    return melodies


def notes2index(notes):
    # Map note values (0-38 for notes, -1 for rest, -2 for hold) to indices of a list or one-hot where:
    # hold = -2 --> 0, rest = -1 --> 1, notes = 0-35 --> 2:37
    # TODO This assumes 36 notes, change if that's not the case
    indices = [] * len(notes)
    for i in range(1, len(notes)):
        if notes[i] == -2:
            indices[i] = 0
        if notes[i] == -1:
            indices[i] = 1
        else:
            # TODO Subtract value of lowest note in our range (here assumed to be C2)
            indices[i] = notes[i] - 36
    return indices


def intlist2onehot(intlist):
    # Turns the integer list representation of a melody into the one-hot encoded array representation of size
    # timesteps X features
    # TODO Check if number of inputs we use is in fact 38 (which is for 36 notes)
    onehot = np.zeros((len(intlist), 38))
    idxs = notes2index(intlist)
    for i in range(len(intlist)):
        onehot[i, idxs[i]] = 1
    return onehot


def onehot2intlist(onehot):
    # Turns the one-hot encoded array representation of a melody into the integer list representation
    intlist = [] * onehot.size[0]
    for i in range(len(intlist)):
        idx = np.where(onehot[i, :] == 1)
        if idx == 0:  # Hold
            intlist[i] = -2
        if idx == -1:  # Rest
            intlist[i] = -1
        else:
            # TODO Add value of lowest note in our range (here assumed to be C2)
            intlist[i] = idx + 36
    return intlist


def check_note_extremes(melodies):
    # Check what the lowest note and highest note are in all songs and checking the maximum distance between notes
    # Just to base decision on about the melody representation
    max_note = 0
    min_note = 128
    max_diff = 0
    for s, m in melodies.items():
        mel_max = max(m)
        mel_min = min(i for i in m if i >= 0)
        mel_diff = mel_max-mel_min
        if mel_max > max_note:
            max_note = mel_max
        if mel_min < min_note:
            min_note = mel_min
        if mel_diff > max_diff:
            max_diff = mel_diff
    return min_note, max_note, max_diff


def melodies_into_register(melodies, upper_thres, lower_thres):

    new_melodies = dict()
    for s in range(len(melodies.keys())):
        shifted_melody = check_register(
            melodies[s], upper_thres, lower_thres, False, False, False, False)
        if(shifted_melody):
            new_melodies[s] = shifted_melody

    return new_melodies

# Initially call with four last parameters set to false


def check_register(melody, upper_thres, lower_thres, moved_up, moved_down, is_above_lower, is_below_upper):
    return check_upper_thres(melody, upper_thres, lower_thres, moved_up, moved_down, is_above_lower, is_below_upper)


def check_upper_thres(melody, upper_thres, lower_thres, moved_up, moved_down, is_above_lower, is_below_upper):

    shifted_melody = []

    for n in range(len(melody)):
        on = melody[n]

        if on > upper_thres:
            # save the difference
            if moved_up == True:
                print("Cannot Shift")
                return None
            moved_down = True
            is_above_lower = False
            # Restart and move all the notes 12 semitones down (except -1 and -2)
            shifted_melody = move_notes(melody, 12, False)
            shifted_melody = check_register(
                shifted_melody, upper_thres, lower_thres, moved_up, moved_down, is_above_lower, is_below_upper)
            return shifted_melody

    # if no note is above the upper threshold
    is_below_upper = True
    if is_above_lower == False:
        return check_lower_thres(melody, upper_thres, lower_thres, moved_up, moved_down, is_above_lower, is_below_upper)
    else:
        return melody


def check_lower_thres(melody, upper_thres, lower_thres, moved_up, moved_down, is_above_lower, is_below_upper):

    shifted_melody = []

    for n in range(len(melody)):
        on = melody[n]

# Take into account the -2, -1
        if 0 < on < lower_thres:
            # save the difference
            if moved_down == True:
                print("Cannot Shift")
                return None
            moved_up = True
            is_below_upper = False
            # Restart and move all the notes 12 semitones down (except -1 and -2)
            shifted_melody = move_notes(melody, 12, True)
            shifted_melody = check_register(
                shifted_melody, upper_thres, lower_thres, moved_up, moved_down, is_above_lower, is_below_upper)
            return shifted_melody

    # if no note is above the upper threshold
    is_above_lower = True
    if is_below_upper == False:
        return check_upper_thres(melody, upper_thres, lower_thres, moved_up, moved_down, is_above_lower, is_below_upper)
    else:
        return melody


def move_notes(fragment, semitones, direction):

    melody = []
    if direction == True:
        for i in fragment:
            if i != -1:
                if i != -2:
                    i = i+semitones
            melody.append(i)
        return melody
    elif direction == False:
        for i in fragment:
            if i != -1:
                if i != -2:
                    i = i-semitones
            melody.append(i)
        return melody


if __name__ == "__main__":
    # melodies = midi_to_int_melody()
    # Examples
    # print(melodies[0])
    # print(melodies[1])

    melodies = melodies_into_register(midi_to_int_melody(), 83, 48)  # C3 -B5

    # Checks the range of notes in the training data
    min_note, max_note, max_diff = check_note_extremes(melodies)
    print("Min note: ", min_note, "Max note: ",
          max_note,  "Max note range: ", max_diff)

    export_midi(list(melodies.values())[0])

    # Important to note: songs are not the same length, some songs start with rest (which could be intentional or just
    # delay in the midi)
