from preprocess_midi import get_all_midi_files2
import numpy as np


def midi_to_int_melody():
    # Assumes melody is in 0th channel, there is always only one note playing at the same time (so note on/off are
    # alternated) meters are the same and ticks_per_beat is 1024. The meter and tick_per_beat are always true for our
    # dataset, the rest is not sure.
    melodies = dict()
    midi_files = get_all_midi_files2()  # Should make sure that only files with proper amount of channels etc.
    for s in range(0,len(midi_files)):
        melody = []
        for n in range(0,len(midi_files[s].channels[0]),2):
            on = midi_files[s].channels[0][n]
            off = midi_files[s].channels[0][n+1]
            nr_notes = (off.time-on.time)//256  # Number of 1/16th notes the note is worth; 256 ticks = 1/16 note

            melody.append(on.note)
            for i in range(0,nr_notes-1):
                melody.append(-2)  # -2 represents holding the note (or rest)
        melodies[s] = melody
    return melodies


def notes2index(notes):
    # Map note values (0-38 for notes, -1 for rest, -2 for hold) to indices of a list or one-hot where:
    # hold = -2 --> 0, rest = -1 --> 1, notes = 0-35 --> 2:37
    # TODO This assumes 36 notes, change if that's not the case
    indices = [] * len(notes)
    for i in range(1, len(notes)):
        if notes[i] == -2:
            indices[i] = 0
        if notes[i] == -1:
            indices[i] = 1
        else:
            indices[i] = notes[i] - 36  # TODO Subtract value of lowest note in our range (here assumed to be C2)
    return indices


def intlist2onehot(intlist):
    # Turns the integer list representation of a melody into the one-hot encoded array representation of size
    # timesteps X features
    onehot = np.zeros((len(intlist), 38))  # TODO Check if number of inputs we use is in fact 38 (which is for 36 notes)
    idxs = notes2index(intlist)
    for i in range(len(intlist)):
        onehot[i, idxs[i]] = 1
    return onehot


def onehot2intlist(onehot):
    # Turns the one-hot encoded array representation of a melody into the integer list representation
    intlist = [] * onehot.size[0]
    for i in range(len(intlist)):
        idx = np.where(onehot[i, :] == 1)[0][0]
        if idx == 0:  # Hold
            intlist[i] = -2
        if idx == -1:  # Rest
            intlist[i] = -1
        else:
            intlist[i] = idx + 36  # TODO Add value of lowest note in our range (here assumed to be C2)
    return intlist


def check_note_extremes(melodies):
    # Check what the lowest note and highest note are in all songs and checking the maximum distance between notes
    # Just to base decision on about the melody representation
    max_note = 0
    min_note = 128
    max_diff = 0
    for s,m in melodies.items():
        mel_max = max(m)
        mel_min = min(i for i in m if i >= 0)
        mel_diff = mel_max-mel_min
        if mel_max > max_note:
            max_note = mel_max
        if mel_min < min_note:
            min_note = mel_min
        if mel_diff > max_diff:
            max_diff = mel_diff
    return min_note,max_note,max_diff


if __name__ == "__main__":
    melodies = midi_to_int_melody()
    # Examples
    #print(melodies[0])
    #print(melodies[1])

    # Checks the range of notes in the training data
    #min_note,max_note,max_diff = check_note_extremes(melodies)
    #print("Min note: ", min_note, "Max note: ", max_note,  "Max note range: ", max_diff)

    # Check length of each song (should actually be length of verse/chorus, but don't have the split yet)
    # Need to know if all are multiple of 16 notes (so each consists of full bars)
    #for s,m in melodies.items():
    #    if len(m)%16 != 0:
    #        print("song ",s, ": length ", len(m))
    #        print(m)
    # TODO: There is a problem with songs where the melody starts delayed (i.e. first chords start). This for instance then makes the melody start with 100 rests (song 178)
    # Might be solved when split into verse/chorus


# Important to note: songs are not the same length, some songs start with rest (which could be intentional or just
# delay in the midi)